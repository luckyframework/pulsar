{"repository_name":"pulsar","body":"# Pulsar\n\n[![API Documentation Website](https://img.shields.io/website?down_color=red&down_message=Offline&label=API%20Documentation&up_message=Online&url=https%3A%2F%2Fluckyframework.github.io%2Fpulsar%2F)](https://luckyframework.github.io/pulsar)\n\nPulsar is a simple Crystal library for publishing and subscribing to events.\nIt also has timing information for metrics. So what does that mean in\npractice?\n\nYou can define an event and any number of subscribers can subscribe to the\nevent and do whatever they need with it.\n\nFor example, in Lucky, we use Pulsar to create events for things like\nrequests being processed, queries being made, before and after pipes running.\nThen we subscribe to these events to write to the logs. We also use this\ninternally to log debugging information in an upcoming UI called Breeze that\nlet's users debug development information.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     pulsar:\n       github: luckyframework/pulsar\n   ```\n\n2. Run `shards install`\n\n## How to use Pulsar\n\nLet's say we're writing a library to charge a credit card and we may want to let\npeople run code whenever a charge is made. Here's how you can do that with Pulsar.\n\n### Create and publish an event\n\n```crystal\nclass PaymentProcessor::ChargeCardEvent < Pulsar::Event\n  def initialize(@amount : Int32)\n  end\nend\n\nclass PaymentProcessor\n  def charge_card(amount : Int32)\n    # Run code to charge the card...\n\n    # Then fire an event\n    PaymentProcessor::ChargeCardEvent.publish(amount)\n  end\nend\n```\n\n### Subscribe to it and do whatever you want with it\n\nNow you can subscribe to the event and do whatever you want with it. For example,\nyou might log that a charge was made, or you might send an email to the sales team.\n\n```crystal\nPaymentProcessor::ChargeCardEvent.subscribe do |event|\n  puts \"Charged: #{event.amount} at #{event.started_at}\"\nend\n```\n\n### Recording timing information\n\nYou can also time how long it takes to run an event by inheriting from\n`Pulsar::TimedEvent`. You define them in the same way, but when you subscribe\nyou must also accept a second argument:\n\n```crystal\nclass Database::QueryEvent < Pulsar::TimedEvent\nend\n\nDatabase::QueryEvent.subscribe do |event, duration|\n  # Do something with the event and duration\nend\n\nDatabase::QueryEvent.publish do\n  # Run a query, run some other code, etc.\nend\n```\n\n### Add more information to the event\n\nTo add more information to the event you can use `initialize` like you would\nwith any other Crystal class.\n\nFor example, we can record the database query in the event from above\n\n```crystal\nclass Database::QueryEvent < Pulsar::TimedEvent\n  getter :query\n\n  def initialize(@query : String)\n  end\nend\n\nDatabase::QueryEvent.subscribe do |event, duration|\n  puts event.query\nend\n\nDatabase::QueryEvent.publish(query: \"SELECT * FROM users\") do\n  # Run a query, run some other code, etc.\nend\n```\n\n## Testing Pulsar events\n\nIf you want to test that events are published you can use Pulsar's built-in test mode.\n\n```crystal\n# Typically in spec/spec_helper.cr\n\n# Must come *after* `require \"spec\"`\nPulsar.enable_test_mode!\n```\n\nThis will enable an in-memory log for published events and will set up a hook to\nclear the events before each spec runs.\n\nYou can access events using `{MyEventClass}.logged_events`.\n\n```crystal\n# Create an event\nclass QueryEvent < Pulsar::TimedEvent\n  def initialize(@query : String)\n  end\nend\n\ndef run_my_query(query)\n  # Publish the event\n  QueryEvent.publish(query: query) do\n    # Run the query somehow\n  end\nend\n\nit \"publishes an event when a SQL query is executed\" do\n  run_my_query \"SELECT * FROM users\n\n  the_published_event = QueryEvent.logged_events.first\n  the_published_event.query.should eq(\"SELECT * FROM users\")\nend\n```\n\n## `Pulsar.elapsed_text`\n\n`Pulsar.elapsed_text` will return the time taken (`Time::Span`) as a human readable String.\n\n```crystal\nDatabase::QueryEvent.subscribe do |event, duration|\n  puts Pulsar.elaspted_text(duration) # \"2.3ms\"\nend\n```\n\nThis method can be used with any `Time::Span`.\n\n## Performance gotchas\n\nSubscribers are notified synchronously in the same Fiber as the publisher.\nThis means that if you have a subscriber that takes a long time to run, it\nwill block anything else from running.\n\nIf you are doing some logging it is probably fine, but if you are doing\nsomething more time-intensive or failure prone like making an HTTP request or\nsaving to the database you should pay special attention.\n\n### Example of a problematic subscriber\n\n```crystal\nMyEvent.subscribe do |event|\n  sleep(5)\nend\n\nMyEvent.publish\n\nputs \"I just took 5 seconds to print!\"\n```\n\nOops. To get around this you can spawn a new fiber:\n\n```crystal\nMyEvent.subscribe do |event|\n  # Now the `sleep` will run in a new Fiber and will not block this one\n  spawn do\n    sleep(5)\n  end\nend\n\nMyEvent.publish\n\nputs \"This will print right away!\"\n```\n\n### Potential solutions\n\nAs described above you could run long running code in a new Fiber with `spawn`.\nYou could also use a background job library like https://github.com/robacarp/mosquito.\n\nBe aware that running things in a Fiber will lose the current Fiber's context. This is\nimportant for logging since `Log.context` only works for the current Fiber.\nSo if you plan to log using the built-in Logger, you likely _do not_ want to\nspawn a new fiber. It is fast enough to just log like normal.\n\n## Contributing\n\n1. Fork it (<https://github.com/luckyframework/pulsar/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [paulcsmith](https://github.com/paulcsmith) - creator and maintainer\n","program":{"html_id":"pulsar/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"pulsar","program":true,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"pulsar/Pulsar","path":"Pulsar.html","kind":"module","full_name":"Pulsar","name":"Pulsar","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"src/pulsar.cr","line_number":3,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar.cr#L3"},{"filename":"src/pulsar/base_event.cr","line_number":1,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar/base_event.cr#L1"}],"repository_name":"pulsar","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[{"id":"EVENT_TYPES","name":"EVENT_TYPES","value":"[] of Pulsar::Event.class | Pulsar::TimedEvent.class","doc":null,"summary":null},{"id":"VERSION","name":"VERSION","value":"\"0.2.2\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[{"html_id":"elapsed_text(elapsed:Time::Span):String-class-method","name":"elapsed_text","doc":"Will return the time taken (`Time::Span`) as a human readable `String`.\n\n```\nDatabase::QueryEvent.subscribe do |event, duration|\n  puts Pulsar.elaspted_text(duration) # \"2.3ms\"\nend\n```\n\nThis method can be used with any `Time::Span`.","summary":"<p>Will return the time taken (<code>Time::Span</code>) as a human readable <code>String</code>.</p>","abstract":false,"args":[{"name":"elapsed","doc":null,"default_value":"","external_name":"elapsed","restriction":"Time::Span"}],"args_string":"(elapsed : Time::Span) : String","args_html":"(elapsed : Time::Span) : String","location":{"filename":"src/pulsar.cr","line_number":54,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar.cr#L54"},"def":{"name":"elapsed_text","args":[{"name":"elapsed","doc":null,"default_value":"","external_name":"elapsed","restriction":"Time::Span"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"minutes = elapsed.total_minutes\nif minutes >= 1\n  return \"#{minutes.round(2)}m\"\nend\nseconds = elapsed.total_seconds\nif seconds >= 1\n  return \"#{seconds.round(2)}s\"\nend\nmillis = elapsed.total_milliseconds\nif millis >= 1\n  return \"#{millis.round(2)}ms\"\nend\n\"#{(millis * 1000).round(2)}Âµs\"\n"}},{"html_id":"enable_test_mode!-class-method","name":"enable_test_mode!","doc":"Enable test mode to log published events\n\nThis will enable an in memory log of events that gets cleared before each\nspec is run. You can access an Event's log using the `logged_events` class\nmethod\n\n```\nMyEvent.publish\n\nMyEvent.logged_events.size.should eq(1)\nMyEvent.logged_events.first # Returns the event that was published\n```","summary":"<p>Enable test mode to log published events</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/pulsar.cr","line_number":20,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar.cr#L20"},"def":{"name":"enable_test_mode!","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"Pulsar.test_mode_enabled = true\nSpec.before_each do\n  Pulsar.test_mode_enabled = true\n  Pulsar.clear_logged_events\nend\n"}},{"html_id":"test_mode_enabled=(test_mode_enabled:Bool)-class-method","name":"test_mode_enabled=","doc":null,"summary":null,"abstract":false,"args":[{"name":"test_mode_enabled","doc":null,"default_value":"","external_name":"test_mode_enabled","restriction":"Bool"}],"args_string":"(test_mode_enabled : Bool)","args_html":"(test_mode_enabled : Bool)","location":{"filename":"src/pulsar.cr","line_number":6,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar.cr#L6"},"def":{"name":"test_mode_enabled=","args":[{"name":"test_mode_enabled","doc":null,"default_value":"","external_name":"test_mode_enabled","restriction":"Bool"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@@test_mode_enabled = test_mode_enabled"}},{"html_id":"test_mode_enabled?:Bool-class-method","name":"test_mode_enabled?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Bool","args_html":" : Bool","location":{"filename":"src/pulsar.cr","line_number":6,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar.cr#L6"},"def":{"name":"test_mode_enabled?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Bool","visibility":"Public","body":"@@test_mode_enabled"}}],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"pulsar/Pulsar/BaseEvent","path":"Pulsar/BaseEvent.html","kind":"class","full_name":"Pulsar::BaseEvent","name":"BaseEvent","abstract":true,"superclass":{"html_id":"pulsar/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"pulsar/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pulsar/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pulsar/base_event.cr","line_number":1,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar/base_event.cr#L1"}],"repository_name":"pulsar","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[{"html_id":"pulsar/Pulsar/Event","kind":"class","full_name":"Pulsar::Event","name":"Event"},{"html_id":"pulsar/Pulsar/TimedEvent","kind":"class","full_name":"Pulsar::TimedEvent","name":"TimedEvent"}],"including_types":[],"namespace":{"html_id":"pulsar/Pulsar","kind":"module","full_name":"Pulsar","name":"Pulsar"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"html_id":"name-instance-method","name":"name","doc":"Returns the name of the event.\n\nThe event name is the name of the class. So an class of `MyShard::MyEvent` would\nreturn `\"MyShard::MyEvent\"`.","summary":"<p>Returns the name of the event.</p>","abstract":false,"args":[],"args_string":"","args_html":"","location":{"filename":"src/pulsar/base_event.cr","line_number":14,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar/base_event.cr#L14"},"def":{"name":"name","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.name"}}],"macros":[],"types":[]},{"html_id":"pulsar/Pulsar/Event","path":"Pulsar/Event.html","kind":"class","full_name":"Pulsar::Event","name":"Event","abstract":true,"superclass":{"html_id":"pulsar/Pulsar/BaseEvent","kind":"class","full_name":"Pulsar::BaseEvent","name":"BaseEvent"},"ancestors":[{"html_id":"pulsar/Pulsar/BaseEvent","kind":"class","full_name":"Pulsar::BaseEvent","name":"BaseEvent"},{"html_id":"pulsar/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pulsar/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pulsar/event.cr","line_number":3,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar/event.cr#L3"}],"repository_name":"pulsar","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pulsar/Pulsar","kind":"module","full_name":"Pulsar","name":"Pulsar"},"doc":null,"summary":null,"class_methods":[{"html_id":"publish(*args_,**named_args_)-class-method","name":"publish","doc":"Publishes the event to all subscribers.\n\n```\nMyEvent.publish\n```\n\n### Passing arguments to initialize\n\nIf your event defines an `initialize` and requires arguments, you can\npass those arguments to `publish`.\n\nFor example if you had the event:\n\n```\nclass MyEvent < Pulsar::Event\n  def initialize(custom_argument : String)\n  end\nend\n```\n\nYou would pass the arguments to `publish` and they will be used to\ninitialize the event:\n\n```\nMyEvent.publish(custom_argument: \"This is my custom event argument\")\n```","summary":"<p>Publishes the event to all subscribers.</p>","abstract":false,"args":[{"name":"args_","doc":null,"default_value":"","external_name":"args_","restriction":""}],"args_string":"(*args_, **named_args_)","args_html":"(*args_, **named_args_)","location":{"filename":"src/pulsar/event.cr","line_number":49,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar/event.cr#L49"},"def":{"name":"publish","args":[{"name":"args_","doc":null,"default_value":"","external_name":"args_","restriction":""}],"double_splat":{"name":"named_args_","doc":null,"default_value":"","external_name":"named_args_","restriction":""},"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(new(*args_, **named_args_)).publish"}},{"html_id":"subscribe(&block:self->Nil)-class-method","name":"subscribe","doc":"Subscribe to events\n\n```\nMyEvent.subscribe do |event|\n  puts event.name # \"MyEvent\"\nend\n\nMyEvent.publish # Will run the block above\n```","summary":"<p>Subscribe to events</p>","abstract":false,"args":[],"args_string":"(&block : self -> Nil)","args_html":"(&block : <span class=\"k\">self</span> -> Nil)","location":{"filename":"src/pulsar/event.cr","line_number":19,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar/event.cr#L19"},"def":{"name":"subscribe","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(self -> Nil)"},"return_type":"","visibility":"Public","body":"self.subscribers << block"}}],"constructors":[],"instance_methods":[{"html_id":"started_at:Time-instance-method","name":"started_at","doc":"When the event started","summary":"<p>When the event started</p>","abstract":false,"args":[],"args_string":" : Time","args_html":" : Time","location":null,"def":{"name":"started_at","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Time","visibility":"Public","body":"@started_at"}}],"macros":[],"types":[]},{"html_id":"pulsar/Pulsar/TimedEvent","path":"Pulsar/TimedEvent.html","kind":"class","full_name":"Pulsar::TimedEvent","name":"TimedEvent","abstract":true,"superclass":{"html_id":"pulsar/Pulsar/BaseEvent","kind":"class","full_name":"Pulsar::BaseEvent","name":"BaseEvent"},"ancestors":[{"html_id":"pulsar/Pulsar/BaseEvent","kind":"class","full_name":"Pulsar::BaseEvent","name":"BaseEvent"},{"html_id":"pulsar/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"pulsar/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/pulsar/timed_event.cr","line_number":3,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar/timed_event.cr#L3"}],"repository_name":"pulsar","program":false,"enum":false,"alias":false,"aliased":null,"aliased_html":null,"const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"pulsar/Pulsar","kind":"module","full_name":"Pulsar","name":"Pulsar"},"doc":null,"summary":null,"class_methods":[{"html_id":"publish(*args_,**named_args_,&)-class-method","name":"publish","doc":"Publishes the event when the block finishes running.\n\nSimilar to `Pulsar::Event#publish` but measures and publishes the time\nit takes to run the block.\n\n```\nMyEvent.publish do\n  # Run some code\nend\n```\n\nThe `publish` method returns the result of the block.\n\n### Passing arguments to initialize\n\nIf your event defines an `initialize` and requires arguments, you can\npass those arguments to `publish`.\n\nFor example if you had the event:\n\n```\nclass MyEvent < Pulsar::TimedEvent\n  def initialize(custom_argument : String)\n  end\nend\n```\n\nYou would pass the arguments to `publish` and they will be used to\ninitialize the event:\n\n```\nMyEvent.publish(custom_argument: \"This is my custom event argument\") do\n  # ...run some code\nend\n```","summary":"<p>Publishes the event when the block finishes running.</p>","abstract":false,"args":[{"name":"args_","doc":null,"default_value":"","external_name":"args_","restriction":""}],"args_string":"(*args_, **named_args_, &)","args_html":"(*args_, **named_args_, &)","location":{"filename":"src/pulsar/timed_event.cr","line_number":60,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar/timed_event.cr#L60"},"def":{"name":"publish","args":[{"name":"args_","doc":null,"default_value":"","external_name":"args_","restriction":""}],"double_splat":{"name":"named_args_","doc":null,"default_value":"","external_name":"named_args_","restriction":""},"splat_index":0,"yields":0,"block_arg":null,"return_type":"","visibility":"Public","body":"(new(*args_, **named_args_)).publish do\n  yield\nend"}},{"html_id":"subscribe(&block:self,Time::Span->Nil)-class-method","name":"subscribe","doc":"Subscribe to events\n\n```\nMyEvent.subscribe do |event, duration|\n  # Do something with the event and duration\nend\n\nMyEvent.publish do\n  # Do something\nend\n```","summary":"<p>Subscribe to events</p>","abstract":false,"args":[],"args_string":"(&block : self, Time::Span -> Nil)","args_html":"(&block : <span class=\"k\">self</span>, Time::Span -> Nil)","location":{"filename":"src/pulsar/timed_event.cr","line_number":21,"url":"https://github.com/luckyframework/pulsar/blob/e2998a21d350e1ae5c308e79295c885be1643af0/src/pulsar/timed_event.cr#L21"},"def":{"name":"subscribe","args":[],"double_splat":null,"splat_index":null,"yields":2,"block_arg":{"name":"block","doc":null,"default_value":"","external_name":"block","restriction":"(self, Time::Span -> Nil)"},"return_type":"","visibility":"Public","body":"self.subscribers << block"}}],"constructors":[],"instance_methods":[{"html_id":"started_at:Time-instance-method","name":"started_at","doc":"When the event started","summary":"<p>When the event started</p>","abstract":false,"args":[],"args_string":" : Time","args_html":" : Time","location":null,"def":{"name":"started_at","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Time","visibility":"Public","body":"@started_at"}}],"macros":[],"types":[]}]}]}}